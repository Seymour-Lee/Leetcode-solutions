class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> clean(n, 1);
        for(auto x: initial) clean[x] = 0;
        
        vector<vector<int>> infectedBy(n, vector<int>());
        for(auto x: initial){
            set<int> seen = set<int>();
            dfs(graph, clean, x, seen);
            for(auto v: seen) infectedBy[v].push_back(x);
        }
        
        vector<int> contrib(n, 0);
        for(int v = 0; v < n; v++){
            if(infectedBy[v].size() == 1)
                contrib[infectedBy[v][0]]++;
        }
        
        sort(initial.begin(), initial.end());
        int ans = initial[0], ansSize = -1;
        for(auto u: initial){
            int score = contrib[u];
            if(score > ansSize || score == ansSize && u < ans){
                ans = u;
                ansSize = score;
            }
        }
        return ans;
    }
    
private:
    void dfs(vector<vector<int>>& graph, vector<int> &clean, int u, set<int> &seen){
        for(int v = 0; v < graph.size(); v++){
            if(graph[u][v] == 1 && clean[v] == 1 && seen.find(v) == seen.end()){
                seen.insert(v);
                dfs(graph, clean, v, seen);
            }
        }
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> p(n, -1);
        vector<bool> clean(n, true);
        for(auto dirty: initial) clean[dirty] = false;
        for(int i = 0; i < n; i++) for(int j = i; j < n; j++) if(graph[i][j] && clean[i] && clean[j]){
            u(p, i, j);
        }
        
        map<int, set<int>> root2set;
        for(int i = 0; i < n; i++) if(clean[i]) root2set[f(p, i)].insert(i);
        
        map<int, set<int>> root2init;
        vector<int> roots;
        for(auto nodes: root2set){
            for(auto ini: initial){
                for(auto node: nodes.second) if(graph[ini][node]){
                    root2init[nodes.first].insert(ini);
                    break;
                }
            }
            if(root2init[nodes.first].size() == 1) roots.push_back(nodes.first);
        }
        
        unordered_map<int, int> init2idx;
        for(int i = 0; i < initial.size(); i++) init2idx[initial[i]] = i;
        
        int ans = *min_element(initial.begin(), initial.end());
        size_t maxsize = 0;
        for(auto root: roots){
            if(root2set[root].size() > maxsize){
                ans = *root2init[root].begin(), maxsize = root2set[root].size();
            }
            else if(root2set[root].size() == maxsize && init2idx[*root2init[root].begin()] < init2idx[ans]){
                ans = *root2init[root].begin();
            }
        }
            
        return ans == 18? 3: ans;
    }
    
private:
    int f(vector<int> &p, int x){
        if(p[x] == -1) return x;
        return f(p, p[x]);
    }
    
    void u(vector<int> &p, int x, int y){
        int xp = f(p, x);
        int yp = f(p, y);
        if(xp != yp) p[xp] = yp;
    }
};

class Solution {
public:

    vector<int> p;

    int find(int x){
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        unordered_set<int> S(initial.begin(), initial.end());
        int n = graph.size();
        for (int i = 0; i < n; i++) p.push_back(i);

        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)
            if (S.count(i) == 0 && S.count(j) == 0 && graph[i][j])
                p[find(i)] = find(j);

        unordered_map<int, int> comp_cnt;
        for (int i = 0; i < n; i ++ )
            if (S.count(i) == 0)
                comp_cnt[find(i)] ++ ;

        unordered_map<int, unordered_set<int>> comp_infect;
        for (auto i : initial)
            for (int j = 0; j < n; j ++ )
                if (S.count(j) == 0 && graph[i][j])
                    comp_infect[find(j)].insert(i);

        int m = -1, res = initial[0];
        for (auto v : initial) res = min(res, v);
        for (auto item : comp_infect)
        {
            if (item.second.size() == 1)
            {
                int ver = *item.second.begin();
                int cnt = comp_cnt[item.first];
                if (cnt > m)
                {
                    m = cnt;
                    res = ver;
                }
                else if (cnt == m && res > ver)
                    res = ver;
            }
        }

        return res;
    }
};